Coming back from shopping, Yihan has got a lot of bags of different candies. She then needs to take all them to the campus. Since they are now in different bags, 
she has to merge all of them into one bag.

She has ğ‘› bags of candies, the ğ‘–-th bag containing ğ‘ğ‘– candies. She can only merge two of them at a time. After two bags are merged, 
with size ğ‘¥ and ğ‘¦ respectively, they become one bag of candies with size ğ‘¥+ğ‘¦. Yihan will repeatedly merge the bags until there is only one bag with size âˆ‘ğ‘›ğ‘–=1ğ‘ğ‘–.
Then she's done and can take the last bag to the campus.

The candies are small and it's easy to lose them when merging them together. To make sure that she doesn't lose any of them, Yihan has to count them carefully. 
Each time before merging of two bags ğ´ and ğµ, she counts the number of candies in bag ğ´, noted as ğ‘¥, and counts the number of candies in bag ğµ, noted as ğ‘¦. 
After merging them, she counts the number of candies in the new bag ğ´âˆªğµ, and check if it's ğ‘¥+ğ‘¦. Thus, during each merge, all candies in the merge is counted twice. 
See the sample I/O explanation for further clarification.

Every counting process means to look at all the candies in the bag, one by one. So it is rather tedious and tiring. 
So Yihan wants to count as few candies as possible. You task is to help Yihan compute how many candies she needs to count at least. 
Given ğ‘› and all ğ‘ğ‘–, output the least number of candies Yihan needs to count. Suppose by carefully counting, Yihan won't lose any candies.

Input
The first line is a single integer ğ‘› (1â‰¤ğ‘›â‰¤106). In each of the next ğ‘› lines, there is an integer that is the initial bag size ğ‘ğ‘–. 0â‰¤ğ‘ğ‘–â‰¤231âˆ’1.

Output
The output contains only one number, which is the fewest number of candies that Yihan has to count. The final output value is guaranteed to be within 263âˆ’1.